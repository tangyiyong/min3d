<html>
<!--
  - Copyright 2011, Terrence Cole
  -
  - This file is part of MIN3D.
  - 
  - MIN3D is free software: you can redistribute it and/or modify
  - it under the terms of the GNU Affero General Public License as published by
  - the Free Software Foundation, either version 3 of the License, or
  - (at your option) any later version.
  - 
  - MIN3D is distributed in the hope that it will be useful,
  - but WITHOUT ANY WARRANTY; without even the implied warranty of
  - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  - GNU Affero General Public License for more details.
  - 
  - You should have received a copy of the GNU Affero General Public License
  - along with MIN3D.  If not, see <http://www.gnu.org/licenses/>.
  -->
<head>
	<title>MIN3D</title>

	<script src="extern/glMatrix-0.9.5.min.js"> </script>
	<script src="extern/jquery-1.6.2.min.js"> </script>
	<script src="main.js"> </script>


<script id="color-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;

	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;

	void main(void) {
		gl_PointSize = 3.0;
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
	}
</script>
<script id="color-fs" type="x-shader/x-fragment">
	#ifdef GL_ES
	precision highp float;
	#endif

	uniform vec4 uColor;
	
	void main(void) {
		gl_FragColor = uColor;
	}
</script>



<script id="skybox-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;

	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;

	varying vec3 vTexCoord;

	void main(void) {
		gl_PointSize = 10.0;
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vTexCoord = aVertexPosition;
	}
</script>
<script id="skybox-fs" type="x-shader/x-fragment">
	#ifdef GL_ES
	precision highp float;
	#endif

	uniform samplerCube uSampler;

	varying vec3 vTexCoord;
	
	void main(void) {
		gl_FragColor = textureCube(uSampler, vTexCoord);
	}
</script>




<script id="cube-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec2 aTextureCoord;
	attribute vec3 aVertexNormal;
	attribute float aState;
	attribute float aFocus;

	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	uniform vec3 uSunDir;
	uniform vec4 uSunColor;
	
	varying vec4 vColor;
	varying vec2 vTextureCoord;
	varying vec3 vTLightVec;
	varying vec3 vTEyeVec;
	varying vec3 vHalfVec;

	void main(void) {
		// figure out what our object space tangent vector is, based on axis
		vec3 faceTangent;
		if(aVertexNormal.y == 0.0) // all side faces
			faceTangent = vec3(0.0, 1.0, 0.0);
		else // the top and bottom faces
			faceTangent = vec3(0.0, 0.0, 1.0);
		vec3 faceBinorm = cross(aVertexNormal, faceTangent);

		// move light vector into tangent space
		vTLightVec.x = dot(uSunDir, faceTangent);
		vTLightVec.y = dot(uSunDir, faceBinorm);
		vTLightVec.z = dot(uSunDir, aVertexNormal);
		vTLightVec = normalize(vTLightVec);
		// move eye vector into tangent space
		vec3 pos = (uMVMatrix * vec4(aVertexPosition, 1.0)).xyz;
		vTEyeVec.x = dot(pos, faceTangent);
		vTEyeVec.y = dot(pos, faceBinorm);
		vTEyeVec.z = dot(pos, aVertexNormal);
		// compute half vector between eye and light
		vec3 h = (normalize(pos) + uSunDir) / 2.0;
		vHalfVec = normalize(h);

		// set color modifier based on state and focus status		
		if(aState == 0.0) { // normal
			vColor = vec4(1.0, 1.0, 1.0, 1.0);
		} else if(aState == 1.0) { // empty
			vColor = vec4(0.0, 0.0, 0.0, 0.0);
		} else {
			vColor = vec4(1.0, 0.0, 0.0, 1.0);
		}
		
		if(aFocus == 1.0) {
			vColor *= vec4(0.7, 0.7, 1.0, 1.0);
		}

		// transform and apply base tc
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
		vTextureCoord = aTextureCoord;
	}
</script>
<script id="cube-fs" type="x-shader/x-fragment">
	#ifdef GL_ES
	precision highp float;
	#endif

	varying vec2 vTextureCoord;
	varying vec3 vTLightVec;
	varying vec3 vTEyeVec;
	varying vec3 vHalfVec;
	varying vec4 vColor;

	uniform sampler2D uSampler;
	uniform sampler2D uNormals;
	uniform sampler2D uReflectivity;
	uniform samplerCube uSkymap;
	
	uniform vec3 uSunDir;
	uniform vec4 uSunColor;

	void main(void) {
		// discard transparent fragments
		if(vColor.w == 0.0) discard;
		
		// lookup and compute base color
		vec4 color = texture2D(uSampler, vTextureCoord);
		color *= vColor;

		// base ambient light
		gl_FragColor = vec4(0.3, 0.3, 0.3, 1.0) * color;

		// perform normal lookup and renormalization
		vec3 normal = texture2D(uNormals, vTextureCoord).xyz;
		normal = normalize(2.0 * normal - 1.0); // renormalize to [-1,1]

		// compute reflection vector
		// vTEyeVec is incident ray in tangent space for this formula
		//		R = I - 2 * N * (N dot I)
		vec3 I = -vTEyeVec;
		vec3 vReflection = I - 2.0 * normal * dot(normal, I);
		
		// lookup sky reflection position using the reflection vector
		vec4 skycolor = textureCube(uSkymap, vReflection);

		// compute diffuse lighting
		float lambertFactor = max(dot(vTLightVec, normal), 0.0);
		if(lambertFactor > 0.0) {
			vec4 mSpecular = vec4(1.0);
			vec4 lSpecular = vec4(1.0);
			float shininess = pow(max(dot(vHalfVec, normal), 0.0), 2.0);
			gl_FragColor += vec4((color * uSunColor * lambertFactor).xyz, 1.0);
			gl_FragColor += mSpecular * lSpecular * shininess;
		}
		
		// mix in the background reflection
		gl_FragColor += skycolor * texture2D(uReflectivity, vTextureCoord) / 2.25;
	}
</script>


<script id="generic-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	uniform mat4 uMVMatrix;
	uniform mat4 uPMatrix;
	void main(void) {
		gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
	}
</script>
<script id="generic-fs" type="x-shader/x-fragment">
	#ifdef GL_ES
	precision highp float;
	#endif

	void main(void) {
        gl_FragColor = vec4(1, 1, 1, 1);
	}
</script>




</head>
<body onload="mined_start();">
	<canvas id="mined-canvas" style="border: 1px solid black;" width="500" height="500" tabindex="1">
		Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
	</canvas>
</body>
</html>
